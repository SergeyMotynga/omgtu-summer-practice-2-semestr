#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading;
//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double[] Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        Stopwatch timer = new Stopwatch();
        timer.Start();
        Thread[] threads = new Thread[threadsnumber];
        Barrier barrier = new Barrier(threadsnumber+1);
        double result = 0.0;
        for(int i = 0; i < threadsnumber; i++){
            double midResult = 0.0;
            double start = a + i * (b-a)/threadsnumber;
            double end = start + (b-a)/threadsnumber;
            threads[i] = new Thread(()=>{
                for(int j = 0; j < (end-start)/step; j++){
                    double x1 = start + j * step;
                    double x2 = x1 + step;
                    midResult += (function(x1)+function(x2))*step/2;
                }
                result += midResult;
                barrier.SignalAndWait();
                });
            threads[i].Start();
        }
        barrier.SignalAndWait();
        timer.Stop();
        return [result, timer.ElapsedMilliseconds];
    }
}

#!csharp

//Многопоточное программирование
#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.35"

using Xunit;
using Microsoft.DotNet.Interactive.Formatting;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

// Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);
// Assert.Equal(10, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
// Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(700, 600)), HtmlFormatter.MimeType);
double[] dataX = new double[12];
double[] dataY = new double[12];
double[] result = new double[2];
double minTime = 1e9;
int threadWithMinTime = 0;
for(int threadsnumber = 1; threadsnumber <= 12; threadsnumber++){
    double resultValue = 0.0;
    double resultTime = 0.0;
    int test = 0;
    for(int tests = 0; tests < 6; tests++){
        result = DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, threadsnumber);
        resultValue = result[0];
        resultTime += result[1];
        test = tests;
        Assert.Equal(0, resultValue, 1e-4);
    }
    dataX[threadsnumber-1] = resultTime/test;
    dataY[threadsnumber-1] = threadsnumber;
    if(minTime >= resultTime/test){
        minTime = resultTime/test;
        threadWithMinTime = threadsnumber;
    }
}
Console.WriteLine($"Оптимальное число потоков - {threadWithMinTime}, выполняется за время: {minTime}мс");
ScottPlot.Plot plt = new();
plt.Add.Scatter(dataX, dataY);
plt

#!csharp

//Однопоточное программирование
using System.Linq;

class TrapezoidalRule_LINQ
{
    public static double Solve(Func<double, double> f, double a, double b, double dx)
    {
        Stopwatch sw = new Stopwatch();
        sw.Start();
        double epsilon = 10E-7;
        if (!double.IsNormal(a)) { throw new ArgumentException("Начало интервала не является число"); }
        if (!double.IsNormal(b)) { throw new ArgumentException("Конец интервала не является числом"); }
        if (dx < epsilon) { throw new ArgumentException("dx меньше epsilon"); }

        int intervals = Convert.ToInt32(Math.Ceiling((b - a) / dx));
        double result = Enumerable.Range(0, intervals).Select(i=>{
            double x1 = a + i * dx;
            double x2 = a + (i + 1) * dx;
            double func = Math.Abs((f(x1) + f(x2))/2 *dx);
            return func;
        }).Sum();
        sw.Stop();
        return sw.ElapsedMilliseconds;
    }
}
var SIN = (double x) => Math.Sin(x);
double time = 0.0;
int test = 0;
for(int i = 0; i < 10; i++){
    time += TrapezoidalRule_LINQ.Solve(SIN, -100, 100, 1e-4);
    test = i;
}
double midTime = time/test;
double percent = midTime/(minTime/100) - 100;
Console.WriteLine($"Среднее время выполнения программы в однопоточном режиме: {midTime}мс");

#!markdown

# Summary
**Оптимальный размер шага:** 1e-4, так как программа выдаёт неточные значения при: 1e-1, 1e-2, 1e-3, а при 1e-5, 1e-6 программа выполняется достаточно долго.

**Оптимальное количество потоков:**

#!csharp

Console.WriteLine($"{threadWithMinTime} потоков за время {minTime}мс.");

#!markdown

**Сравнение скорости выполнения многопоточной программы и однопоточной:**

#!csharp

Console.WriteLine($"Многопоточная программа: {minTime}мс \nОднопоточная программа: {midTime}мс\nМногопоточная программа выполняется на {Convert.ToInt32(percent)}% быстрее однопоточной.")

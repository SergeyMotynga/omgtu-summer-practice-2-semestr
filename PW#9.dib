#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

public interface ICommand
{
    bool isCompleted{get;}
    void Execute();
}


public class TestCommand(int id, int count) : ICommand
{
    int counter = 1;
    public bool isCompleted{get;set;}
    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {counter}");
        counter++;
        if(counter == count){
            isCompleted = true;
        }
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"
using System;
using System.Collections.Concurrent;
using System.Threading;
using Xunit;

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}
public class RoundRobin: IScheduler{
    Queue<ICommand> commands = new Queue<ICommand>();
    public bool HasCommand(){
        return commands.Count > 0;
    }
    public ICommand Select(){
        if(!HasCommand()){
            return null;
        }
        ICommand cmd = commands.Dequeue();
        if (!cmd.isCompleted)
        {
            commands.Enqueue(cmd);
        }
        return cmd;
    }
    public void Add(ICommand cmd){
        commands.Enqueue(cmd);
    }
}
public class HardStop: ICommand{
    ServerThread thread;
    public bool isCompleted{get;set;}
    public HardStop(ServerThread thread) {
        this.thread = thread;
        isCompleted = false;
    }
    public void Execute() {
        Assert.Equal(thread.GetThread(), Thread.CurrentThread);
        thread.Stop();
        isCompleted = true;
    }
}
public class SoftStop: ICommand{
    ServerThread thread;
    public bool isCompleted{get;set;}
    public SoftStop(ServerThread thread) {
        this.thread = thread;
        isCompleted = false;
    }
    public void Execute() {
        Assert.Equal(thread.GetThread(), Thread.CurrentThread);
        thread.QueueIsEmpty();
        isCompleted = true;
    }
}
public class ServerThread{
    Thread thread;
    bool isRunning = true;
    bool queueIsEmpty = false;
    ConcurrentQueue<ICommand> commands = new ConcurrentQueue<ICommand>();
    IScheduler scheduler;
    public ServerThread(IScheduler scheduler){
        this.scheduler = scheduler;
        thread = new Thread(Run);
        thread.Start();
    }
    public void EnqueueCommand(ICommand command){
        commands.Enqueue(command);
    }
    public void Run(){
        while(isRunning){
            ICommand command = null;
            if(scheduler.HasCommand()){
                command = scheduler.Select();
            }
            else if(commands.TryDequeue(out command)){
                scheduler.Add(command);
            }
            if(command != null){
                command.Execute();
            }
            else if(queueIsEmpty && commands.IsEmpty && !scheduler.HasCommand()){
                isRunning = false;
                break;
            }
        }
    }
    public Thread GetThread(){
        return thread;
    }
    public void Stop(){
        isRunning = false;
    }
    public void QueueIsEmpty(){
        queueIsEmpty = true;
    }
}

#!csharp

IScheduler scheduler = new RoundRobin();
var serverThread = new ServerThread(scheduler);
for (int i = 1; i < 10; i++){
     if(i > 5) serverThread.EnqueueCommand(new HardStop(serverThread));
     serverThread.EnqueueCommand(new TestCommand(i,3));
}
serverThread.GetThread().Join();
Console.WriteLine("Выполнилась жёсткая остановка.");

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
